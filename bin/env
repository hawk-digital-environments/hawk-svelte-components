#!/usr/bin/env bash
# This script was generated by bashly 1.2.10 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
env_usage() {
  printf "env - Environment Control application\n\n"

  printf "%s\n" "Usage:"
  printf "  env COMMAND\n"
  printf "  env [COMMAND] --help | -h\n"
  printf "  env --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   similar to docker-compose up, but sets all the required environment variables for buildkit. (All docker command options are valid)\n" "up         "
  printf "  %s   simple alias to docker-compose stop\n" "stop       "
  printf "  %s   simple alias to docker-compose stop and docker-compose up\n" "restart    "
  printf "  %s   simple alias to docker-compose down\n" "down       "
  printf "  %s   removes the existing container image\n" "clean      "
  printf "  %s   simple alias to docker-compose logs (All docker command options are valid)\n" "logs       "
  printf "  %s   builds the docker image for local testing\n" "build      "
  printf "  %s   rebuilds the bashly application you are currently using, based on the sources\n" "rebuild-cli"
  printf "  %s   basically your docker-compose exec into the main app container\n" "ssh        "
  printf "  %s   runs a certain npm command for the project\n" "npm        "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
env_up_usage() {
  printf "env up - similar to docker-compose up, but sets all the required environment variables for buildkit. (All docker command options are valid)\n\n"

  printf "%s\n" "Usage:"
  printf "  env up [OPTIONS] [--] [...]\n"
  printf "  env up --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--attach, -f"
    printf "    By default, the containers are started daemonized, use this to attach to\n    their output\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_stop_usage() {
  printf "env stop - simple alias to docker-compose stop\n\n"

  printf "%s\n" "Usage:"
  printf "  env stop [--] [...]\n"
  printf "  env stop --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_restart_usage() {
  printf "env restart - simple alias to docker-compose stop and docker-compose up\n\n"

  printf "%s\n" "Usage:"
  printf "  env restart [OPTIONS]\n"
  printf "  env restart --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    Force the restart of the containers (using docker-compose down)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--attach, -a"
    printf "    Do not start the new containers deamonized, but attach to their output\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_down_usage() {
  printf "env down - simple alias to docker-compose down\n\n"

  printf "%s\n" "Usage:"
  printf "  env down [--] [...]\n"
  printf "  env down --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_clean_usage() {
  printf "env clean - removes the existing container image\n\n"

  printf "%s\n" "Usage:"
  printf "  env clean [OPTIONS]\n"
  printf "  env clean --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--yes, -y"
    printf "    Don't ask just do...\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_logs_usage() {
  printf "env logs - simple alias to docker-compose logs (All docker command options are valid)\n\n"

  printf "%s\n" "Usage:"
  printf "  env logs [SERVICE] [--] [...]\n"
  printf "  env logs --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SERVICE"
    printf "    Allows you to define which service you want to connect to\n"
    echo

  fi
}

# :command.usage
env_build_usage() {
  printf "env build - builds the docker image for local testing\n\n"

  printf "%s\n" "Usage:"
  printf "  env build\n"
  printf "  env build --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_rebuild_cli_usage() {
  printf "env rebuild-cli - rebuilds the bashly application you are currently using, based on the sources\n\n"

  printf "%s\n" "Usage:"
  printf "  env rebuild-cli\n"
  printf "  env rebuild-cli --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_ssh_usage() {
  printf "env ssh - basically your docker-compose exec into the main app container\n\n"
  printf "Alias: shell\n"
  echo

  printf "%s\n" "Usage:"
  printf "  env ssh [SERVICE] [OPTIONS]\n"
  printf "  env ssh --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--cmd, -c COMMAND"
    printf "    By default, we will use the users configured shell, you can use \"sh\" or any\n    other command if you want to\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SERVICE"
    printf "    Allows you to define which service you want to connect to\n"
    echo

  fi
}

# :command.usage
env_npm_usage() {
  printf "env npm - runs a certain npm command for the project\n\n"

  printf "%s\n" "Usage:"
  printf "  env npm [--] [...]\n"
  printf "  env npm --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# _env/src/lib/docker.sh
determineDockerExecutable(){
  local PODMAN_EXECUTABLE
  PODMAN_EXECUTABLE=$(command -v podman)
  if [[ "${PODMAN_EXECUTABLE}" ]] && (systemctl is-active --quiet podman); then
    echo "${PODMAN_EXECUTABLE}"
    return
  fi

  local DOCKER_EXECUTABLE
  DOCKER_EXECUTABLE=$(command -v docker)
  if [[ "${DOCKER_EXECUTABLE}" ]]; then
    echo "${DOCKER_EXECUTABLE}"
    return
  fi

  echo "Sorry, but I did not find docker or podman on your system" >&2
  exit 1
}

determineDockerComposeExecutable() {
  # Special switch for pod-man
  local PODMAN_PATH
  PODMAN_PATH=$(command -v podman-compose)
	if [[ ${PODMAN_PATH} ]] && (systemctl is-active --quiet podman); then
		echo "${PODMAN_PATH}"
		return
	fi

  local PODMAN_PATH
  PODMAN_PATH=$(command -v podman)
	if [[ ${PODMAN_PATH} ]] && (systemctl is-active --quiet podman); then
		echo "${PODMAN_PATH} compose"
		return
	fi

	local COMPOSE_PATH
	COMPOSE_PATH=$(command -v docker-compose)

	# Check if some WSL weirdness is going on
	if [[ ${COMPOSE_PATH} ]] && [[ ${COMPOSE_PATH} != /mnt/* ]]; then
		# No wsl weirdness is going on -> return the path as is...
		echo "${COMPOSE_PATH}"
		return
	fi

	local COMPOSE_VERSION
	COMPOSE_VERSION=$(docker compose version)

	if [[ ${COMPOSE_VERSION} == *v2* ]]; then
		echo "docker compose"
		return
	fi

  echo "Sorry, but I did not find docker-compose or 'docker compose' on your system" >&2
  exit 1
}

determineDockerRuntimeType(){
  local COMPOSE_EXECUTABLE
  COMPOSE_EXECUTABLE=$(determineDockerComposeExecutable)
  if [[ "${COMPOSE_EXECUTABLE}" == *podman* ]]; then
    echo "podman"
    return
  fi
  echo "docker"
}

provideDockerEnvironmentVariablesBasedOnRuntimeType(){
  echo "export BUILDKIT_PROGRESS=plain"
  echo "export COMPOSE_DOCKER_CLI_BUILD=1"
  echo "export DOCKER_BUILDKIT=1"

  if [[ ${DOCKER_RUNTIME_TYPE} == "podman" ]]; then
    echo "export DOCKER_RUNTIME=podman"
    echo "export DOCKER_USER=root"
  else
    echo "export DOCKER_RUNTIME=docker"
    echo "export DOCKER_USER=${DEFAULT_UID}:${DEFAULT_GID}"
    echo "export DOCKER_UID=${DEFAULT_UID}"
    echo "export DOCKER_GID=${DEFAULT_GID}"
  fi
}

isDockerComposeServiceRunning() {
  [[ $(getContainerIdFromServiceName "${1:-${DEFAULT_SERVICE_NAME}}") ]]
}

isDockerContainerWithNameRunning() {
  [[ $($DOCKER_EXECUTABLE ps -q -f name="${1}") ]]
}

getContainerIdFromServiceName(){
	$DOCKER_COMPOSE_EXECUTABLE ps -q "${1:-${DEFAULT_SERVICE_NAME}}"
}

getToolsContainerName() {
  echo "${PROJECT_NAME:-project-without-name}-tools"
}

dockerUp() {
  $DOCKER_COMPOSE_EXECUTABLE up -d "$@"
}

dockerUpAttach() {
    $DOCKER_COMPOSE_EXECUTABLE up "$@"
}

dockerStop() {
  stopToolsContainer
  $DOCKER_COMPOSE_EXECUTABLE stop "$@"
}

dockerDown() {
  stopToolsContainer
  $DOCKER_COMPOSE_EXECUTABLE down "$@"
}

dockerSsh() {
  SERVICE=${1:-${DEFAULT_SERVICE_NAME}}
  CMD=${2}
  if ! isDockerComposeServiceRunning ${SERVICE}; then

    dockerUp
  fi

  CONTAINER_ID=$(getContainerIdFromServiceName "$SERVICE")
  BASH_SHELL=$($DOCKER_EXECUTABLE exec "${CONTAINER_ID}" which bash || echo "")
  if [[ -n "${BASH_SHELL}" ]]; then
    CONFIGURED_SHELL=${BASH_SHELL}
  else
    SH_SHELL=$($DOCKER_EXECUTABLE exec "${CONTAINER_ID}" which sh || echo "")
    if [[ -n "${SH_SHELL}" ]]; then
      CONFIGURED_SHELL=${SH_SHELL}
    else
      CONFIGURED_SHELL=$($DOCKER_EXECUTABLE exec "${CONTAINER_ID}" getent passwd root | cut -d: -f7)
    fi
  fi

  if [[ -z "${CONFIGURED_SHELL}" ]]; then
    echo "Could not determine the shell of the container" >&2
    exit 1
  fi

  COMMAND_PARAM=""
  if [[ -n "${CMD}" ]]; then
    $DOCKER_EXECUTABLE exec -ti "${CONTAINER_ID}" "${CONFIGURED_SHELL}" -c "${CMD}"
    return
  fi

  $DOCKER_EXECUTABLE exec -ti "${CONTAINER_ID}" "${CONFIGURED_SHELL}"
}

startToolsContainerIfNotRunning() {
  local CURRENT_DIR
  CURRENT_DIR=$(pwd)

  cd "${TOOLS_DIR}" || echo "Could not change to tools directory" >&2 && exit 1
  local CONTAINER_NAME
  CONTAINER_NAME=$(getToolsContainerName)
  if ! isDockerContainerWithNameRunning ${CONTAINER_NAME}; then
		$DOCKER_COMPOSE_EXECUTABLE run \
			--detach \
			--name ${CONTAINER_NAME} \
			--rm \
			--entrypoint "" \
			tools \
			bash -c "while true; do sleep 86400; done"
  fi
  cd "${CURRENT_DIR}" || echo "Could not change back to original directory" >&2 && exit 1
}

stopToolsContainer(){
  local CONTAINER_NAME
  CONTAINER_NAME=$(getToolsContainerName)
  if isDockerContainerWithNameRunning "${CONTAINER_NAME}"; then
    echo "Stopping tools container..." > /dev/tty
    $DOCKER_EXECUTABLE stop "${CONTAINER_NAME}"
  fi
}

getToolsContainerExecutable() {
  local ADDITIONAL_ARGS=${@}
  local TOOLS_COMPOSE_FILE="${TOOLS_DIR}/docker-compose.yml"
  echo "$DOCKER_COMPOSE_EXECUTABLE --file ${TOOLS_COMPOSE_FILE} run --rm --entrypoint \"\" ${ADDITIONAL_ARGS} tools"
}

# _env/src/lib/envFile.sh
# Loads the script environment file or dies if it does not exist
loadEnvFile(){
  ENV_FILE=${ENV_FILE:-"${PROJECT_ROOT_DIR}/.env"}

  if [ ! -f ${ENV_FILE} ]; then
    if [ -f "${ENV_FILE}.tpl" ] && confirmDefaultYes "Looks like you're missing the ${ENV_FILE} file. Would you like to create it using the .env.tpl file?"; then
      cp "${ENV_FILE}.tpl" "${ENV_FILE}"
    else
      echo "Missing ${ENV_FILE} file! Please copy .env.tpl, rename it to .env and add the required values before continuing!";
      exit 1;
    fi
  fi

  source ${ENV_FILE}

  if ! [[ ${PROJECT_NAME} ]]; then
    echo "The PROJECT_NAME variable is not set in the .env file! Please set one before continuing...";
    local NAME=$(askForProjectName)
    echo "PROJECT_NAME=${NAME}" >> ${ENV_FILE}
  elif [[ ${PROJECT_NAME} = 'replace-me' ]]; then
    echo "Please replace the default project name in the .env file with your project name..."
    local NAME=$(askForProjectName)
    _sed "${ENV_FILE}" -i "s/PROJECT_NAME=replace-me/PROJECT_NAME=${NAME}/"
  fi
}

askForProjectName() {
  local NAME
  while true; do
    read -p 'project name: ' NAME
    if [[ ! ${NAME} =~ ^[a-zA-Z0-9-]+$ ]]; then
      echo "The project name can only contain alphanumeric characters and dashes!" > /dev/tty;
    else
      break
    fi
  done
  echo ${NAME}
}

# _env/src/lib/tools.sh
# Executes a jq json lookup. See: https://jqlang.github.io/jq/
# Use like this: cat "./your.json" | jq "-r '.services.db.environment.MYSQL_ROOT_PASSWORD'"
_jq() {
	$(getToolsContainerExecutable -i) jq "$@"
}

# Returns a pipe viewer for the provided input path
# Use like this: pv "./your.file" | someCommandToUseYourFile
_pv() {
	INPUT_PATH=${1}
	cat "${INPUT_PATH}" | $(getToolsContainerExecutable -i) pv -s $(stat -L "${INPUT_PATH}" -c "%s") -f
}

# Executes a sed action on the provided input
# Use like normal sed, BUT pass the file path as the first argument!
_sed() {
  local FILE_PATH=${1}
  local VOLUME_PATH=$(dirname "${FILE_PATH}")
  local FILE_NAME=$(basename "${FILE_PATH}")
  shift
  $(getToolsContainerExecutable -i -v "${VOLUME_PATH}":/opt/work) sed "$@" /opt/work/"${FILE_NAME}"
}

# _env/src/lib/util.sh
# Asserts that the provided command exist, or kills the script
assertCommandExists(){
  MESSAGE=${2:-"Error: the required executable ${1} does not exist"}
  if ! [ -x "$(command -v $1)" ]; then
    echo "${MESSAGE}" >&2
    exit 1
  fi
}

# Asks the user for confirmation and assumes yes should be the default answer
confirmDefaultYes(){
  QUESTION=${1:-"Are you sure?"}
  read -r -p "${QUESTION} [Y/n] " RESPONSE
  RESPONSE=${RESPONSE,,}

  if [[ "${RESPONSE}" =~ ^(yes|y)$ ]] || [[ ${RESPONSE} == "" ]]; then
    return
  fi

  false
}

# Asks the user for confirmation and assumes no should be the default answer
confirmDefaultNo(){
  QUESTION=${1:-"Are you sure?"}
  read -r -p "${QUESTION} [y/N] " RESPONSE
  RESPONSE=${RESPONSE,,}

  if [[ "${RESPONSE}" =~ ^(no|n)$ ]] || [[ ${RESPONSE} == "" ]]; then
  	false
    return
  fi
}

# Checks the last exit code and kills the script if it is bigger than 0
checkLastExitCodeOrDie(){
  CODE=${1:-$?}
  MESSAGE=${2:-"There was an issue with running a task"}

  if [ ${CODE} -ne 0 ]
  then
    echo "${MESSAGE}" >&2
    exit 1
  fi
}

determineHostType() {
  OS='unsupported';
  case "$OSTYPE" in
    darwin*)  OS="OSX" ;;
    linux*)   OS="LINUX" ;;
    msys*)    OS="WINDOWS" ;;
    cygwin*)  OS="WINDOWS" ;;
  esac

  echo $OS
  return
}

determineOsPlatform() {
  if [[ $OS_TYPE == 'LINUX' || $OS_TYPE == 'OSX' ]]; then
    echo $(uname -m)
    return
  fi

  if [[ $OS_TYPE == 'WINDOWS' ]]; then
    echo %PROCESSOR_ARCHITECTURE%
    return
  fi
}

isWslMachine() {
  if [[ $(grep Microsoft /proc/version) ]]; then
    return
  fi
  if [[ $(grep microsoft /proc/version) ]]; then
    return
  fi

  false
}

# :command.command_functions
# :command.function
env_up_command() {

  # _env/src/up_command.sh
  ARGS=${other_args[*]}

  # If attach is set, execute dockerUpAttach, otherwise execute dockerUp
  if ! [[ -z ${args[--attach]} ]]; then
    dockerUpAttach ${ARGS}
  else
    dockerUp ${ARGS}
  fi

}

# :command.function
env_stop_command() {

  # _env/src/stop_command.sh
  dockerStop ${other_args[*]}

}

# :command.function
env_restart_command() {

  # _env/src/restart_command.sh
  # If force is set execute dockerDown, otherwise execute dockerStop
  if ! [[ -z ${args[--force]} ]]; then
    dockerDown
  else
    dockerStop
  fi

  # If attach is set, execute dockerUpAttach, otherwise execute dockerUp
  if ! [[ -z ${args[--attach]} ]]; then
    dockerUpAttach
  else
    dockerUp
  fi

}

# :command.function
env_down_command() {

  # _env/src/down_command.sh
  dockerDown ${other_args[*]}

}

# :command.function
env_clean_command() {

  # _env/src/clean_command.sh
  if [[ ${args[--yes]} ]] || confirmDefaultYes 'Should really remove the image build for this project from your disk?';
  then
    runSubCommand stop
    if [[ ${DOCKER_RUNTIME_TYPE} == 'docker' ]]; then
      ${DOCKER_COMPOSE_EXECUTABLE} down --rmi all --volumes
  	  ${DOCKER_COMPOSE_EXECUTABLE} rm --force --stop --volumes
    else
     ${DOCKER_COMPOSE_EXECUTABLE} down
    fi
  fi

}

# :command.function
env_logs_command() {

  # _env/src/logs_command.sh
  ARGS=${other_args[*]}

  $DOCKER_COMPOSE_EXECUTABLE logs ${args[service]:-$DEFAULT_SERVICE_NAME} $ARGS

}

# :command.function
env_build_command() {

  # _env/src/build_command.sh
  SERVICE_NAME=app
  $DOCKER_COMPOSE_EXECUTABLE build ${SERVICE_NAME}

}

# :command.function
env_rebuild_cli_command() {

  # _env/src/rebuild_cli_command.sh
  if confirmDefaultYes "This will regenerate the bin/env script, based on the sources under bin/_env! Are you sure you want to continue?";
  then
    echo "Okay, lets do this...";
  else
    echo "Okay, aborting!";
    exit
  fi

  "${BIN_DIR}/_env/bashly.sh" generate

}

# :command.function
env_ssh_command() {

  # _env/src/ssh_command.sh
  SERVICE=${args[service]:-$DEFAULT_SERVICE_NAME}
  CMD=${args[--cmd]}

  dockerSsh ${SERVICE} "${CMD}"

}

# :command.function
env_npm_command() {

  # _env/src/npm_command.sh
  CMD="${other_args[*]}"

  dockerSsh node "npm ${CMD}"

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        env_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    up)
      action="up"
      shift
      env_up_parse_requirements "$@"
      shift $#
      ;;

    stop)
      action="stop"
      shift
      env_stop_parse_requirements "$@"
      shift $#
      ;;

    restart)
      action="restart"
      shift
      env_restart_parse_requirements "$@"
      shift $#
      ;;

    down)
      action="down"
      shift
      env_down_parse_requirements "$@"
      shift $#
      ;;

    clean)
      action="clean"
      shift
      env_clean_parse_requirements "$@"
      shift $#
      ;;

    logs)
      action="logs"
      shift
      env_logs_parse_requirements "$@"
      shift $#
      ;;

    build)
      action="build"
      shift
      env_build_parse_requirements "$@"
      shift $#
      ;;

    rebuild-cli)
      action="rebuild-cli"
      shift
      env_rebuild_cli_parse_requirements "$@"
      shift $#
      ;;

    ssh | shell)
      action="ssh"
      shift
      env_ssh_parse_requirements "$@"
      shift $#
      ;;

    npm)
      action="npm"
      shift
      env_npm_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      env_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
env_up_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        env_up_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="up"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --attach | -f)

        # :flag.case_no_arg
        args['--attach']=1
        shift
        ;;

      --)
        shift
        other_args+=("$@")
        break
        ;;

      -?*)
        other_args+=("$1")
        shift
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_catch_all
        other_args+=("$1")
        shift

        ;;

    esac
  done

}

# :command.parse_requirements
env_stop_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        env_stop_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="stop"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --)
        shift
        other_args+=("$@")
        break
        ;;

      -?*)
        other_args+=("$1")
        shift
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_catch_all
        other_args+=("$1")
        shift

        ;;

    esac
  done

}

# :command.parse_requirements
env_restart_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        env_restart_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="restart"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      # :flag.case
      --attach | -a)

        # :flag.case_no_arg
        args['--attach']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
env_down_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        env_down_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="down"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --)
        shift
        other_args+=("$@")
        break
        ;;

      -?*)
        other_args+=("$1")
        shift
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_catch_all
        other_args+=("$1")
        shift

        ;;

    esac
  done

}

# :command.parse_requirements
env_clean_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        env_clean_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="clean"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --yes | -y)

        # :flag.case_no_arg
        args['--yes']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
env_logs_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        env_logs_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="logs"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --)
        shift
        other_args+=("$@")
        break
        ;;

      -?*)
        other_args+=("$1")
        shift
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_catch_all
        # :argument.case
        if [[ -z ${args['service']+x} ]]; then
          args['service']=$1
          shift
        else
          other_args+=("$1")
          shift
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
env_build_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        env_build_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="build"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
env_rebuild_cli_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        env_rebuild_cli_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="rebuild-cli"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
env_ssh_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        env_ssh_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="ssh"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --cmd | -c)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--cmd']="$2"
          shift
          shift
        else
          printf "%s\n" "--cmd requires an argument: --cmd, -c COMMAND" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['service']+x} ]]; then
          args['service']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
env_npm_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        env_npm_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="npm"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --)
        shift
        other_args+=("$@")
        break
        ;;

      -?*)
        other_args+=("$1")
        shift
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_catch_all
        other_args+=("$1")
        shift

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  declare -g version="1.0.0"
  set -e

  # _env/src/initialize.sh
  BIN_DIR=$(realpath "${BASH_SOURCE%/*}")
  TOOLS_DIR=$(realpath "${BIN_DIR}/_env/tools")
  PROJECT_ROOT_DIR=$(realpath "${BIN_DIR}/..")

  OS_TYPE=$(determineHostType)

  if [[ $OS_TYPE == 'unsupported' ]]; then
    echo 'Sorry, but we currently don''t support your operating system!'
    exit 1
  fi

  OS_PLATFORM=$(determineOsPlatform)

  DOCKER_EXECUTABLE=$(determineDockerExecutable)
  DOCKER_COMPOSE_EXECUTABLE=$(determineDockerComposeExecutable)
  DOCKER_RUNTIME_TYPE=$(determineDockerRuntimeType)

  loadEnvFile

  DEFAULT_SERVICE_NAME=${SERVICE_NAME:-app}
  DEFAULT_CONTAINER_NAME="${PROJECT_NAME:-project-without-name}-${DEFAULT_SERVICE_NAME}"
  DEFAULT_UID=${ENV_UID:-$(id -u)}
  DEFAULT_GID=${ENV_GID:-$(id -g)}

  $(provideDockerEnvironmentVariablesBasedOnRuntimeType)

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -a other_args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "up") env_up_command ;;
    "stop") env_stop_command ;;
    "restart") env_restart_command ;;
    "down") env_down_command ;;
    "clean") env_clean_command ;;
    "logs") env_logs_command ;;
    "build") env_build_command ;;
    "rebuild-cli") env_rebuild_cli_command ;;
    "ssh") env_ssh_command ;;
    "npm") env_npm_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  initialize
  run "$@"
fi
